.\" Automatically generated by Pod::Man 2.1801 (Pod::Simple 3.08)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Bio::Graphics::Browser::Realign 3"
.TH Bio::Graphics::Browser::Realign 3 "2009-09-27" "perl v5.10.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Bio::Graphics::Browser::Realign \- Perl extension for Smith\-Waterman alignments
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&  use Bio::Graphics::Browser::Realign \*(Aqalign\*(Aq;
\&  my ($top,$middle,$bottom) = align(\*(Aqgattttttc\*(Aq,\*(Aqgattttccc\*(Aq);
\&  print join "\en",$top,$middle,$bottom,"\en";
\&
\&  # produces:
\&  gatttttt\-\-c
\&  ||||||    |
\&  gatttt\-\-ccc
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a helper utility used by gbrowse to produce global alignments.
It uses slow Smith-Waterman, so is only appropriate for short segments
that are mostly aligned already.
.PP
It can be speeded up significantly by compiling
Bio::Graphics::Browser::CAlign, an \s-1XS\s0 extension.  To do this, build
gbrowse with the DO_XS=1 option:
.PP
.Vb 2
\&  cd Generic\-Genome\-Browser
\&  perl Makefile.PL DO_XS=1
.Ve
.SS "\s-1METHODS\s0"
.IX Subsection "METHODS"
.ie n .IP "$aligner = Bio::Graphics::Browser::Realign\->new($src,$target [,\e%matrix])" 4
.el .IP "\f(CW$aligner\fR = Bio::Graphics::Browser::Realign\->new($src,$target [,\e%matrix])" 4
.IX Item "$aligner = Bio::Graphics::Browser::Realign->new($src,$target [,%matrix])"
The \fInew()\fR method takes two the two sequence strings to be aligned and
an optional weight matrix.  Legal weight matrix keys and their default
values are shown here:
.Sp
.Vb 2
\&   Key name       Default       Description
\&   \-\-\-\-\-\-\-\-       \-\-\-\-\-\-\-       \-\-\-\-\-\-\-\-\-\-\-
\&
\&   match            1           Award one point for an exact match.
\&   mismatch        \-1           Penalize one point for a mismatch.
\&   wildcard_match   0           No penalty for a match to a wildcard (e.g. "n").
\&   gap             \-1           Penalize one point to create a gap.
\&   gap_extend       0           No penalty for extending an existing gap.
\&   wildcard         \*(AqN\*(Aq         The wildcard character.
.Ve
.Sp
The alignment algorithm is run when \fInew()\fR is called.
.ie n .IP "$score = $aligner\->score" 4
.el .IP "\f(CW$score\fR = \f(CW$aligner\fR\->score" 4
.IX Item "$score = $aligner->score"
Return the score from the alignment.
.ie n .IP "$start = $aligner\->start" 4
.el .IP "\f(CW$start\fR = \f(CW$aligner\fR\->start" 4
.IX Item "$start = $aligner->start"
Return the start of the aligned region, in source sequence
coordinates.
.ie n .IP "$end = $aligner\->end" 4
.el .IP "\f(CW$end\fR = \f(CW$aligner\fR\->end" 4
.IX Item "$end = $aligner->end"
Return the end of the aligned region, in source sequence
coordinates.
.ie n .IP "$arrayref = $aligner\->alignment" 4
.el .IP "\f(CW$arrayref\fR = \f(CW$aligner\fR\->alignment" 4
.IX Item "$arrayref = $aligner->alignment"
Return an arrayref representing the alignment.  The array will be
exactly as long as the source sequence.  Its indexes correspond to
positions on the source sequence, and its values correspond to
positions on the target sequence.  An unaligned base is indicated as
undef.  Indexes are zero-based.
.Sp
For example, this alignment:
.Sp
.Vb 3
\&  gatttttt\-\-c
\&  ||||||    |
\&  gatttt\-\-ccc
.Ve
.Sp
corresponds to this arrayref:
.Sp
.Vb 10
\&   index    value
\&   0[g]    0[g]
\&   1[a]    1[a]
\&   2[t]    2[t]
\&   3[t]    3[t]
\&   4[t]    4[t]
\&   5[t]    5[t]
\&   6[t]    undef
\&   7[t]    undef
\&   8[c]    8[c]
.Ve
.ie n .IP "($top,$middle,$bottom) = $aligner\->pads" 4
.el .IP "($top,$middle,$bottom) = \f(CW$aligner\fR\->pads" 4
.IX Item "($top,$middle,$bottom) = $aligner->pads"
Returns the alignment as three padded strings indicating the top,
middle and bottom lines of a pretty-printed representation.
.Sp
For example:
.Sp
.Vb 1
\&  print join "\en",$aligner\->pads;
.Ve
.Sp
Will produce this output:
.Sp
.Vb 3
\&  gatttttt\-\-c
\&  ||||||    |
\&  gatttt\-\-ccc
.Ve
.SS "\s-1EXPORTED\s0 \s-1METHODS\s0"
.IX Subsection "EXPORTED METHODS"
No functions are exported by default, but the following two methods
can be imported explicitly.
.IP "($top,$middle,$bottom) = align($source,$target [,\e%matrix])" 4
.IX Item "($top,$middle,$bottom) = align($source,$target [,%matrix])"
Align the source and target sequences and return the padded strings
representing the alignment.  It is exactly equivalent to calling:
.Sp
.Vb 1
\&  Bio::Graphics::Browser::Realign\->new($source,$target)\->pads;
.Ve
.ie n .IP "$segs_arrayref = align_segs($source,$target [,\e%matrix])" 4
.el .IP "\f(CW$segs_arrayref\fR = align_segs($source,$target [,\e%matrix])" 4
.IX Item "$segs_arrayref = align_segs($source,$target [,%matrix])"
The \fIalign_segs()\fR function aligns \f(CW$source\fR and \f(CW$target\fR and returns an
array of non-gapped segments.  Each element of the array corresponds
to a contiguous nongapped alignment in the format
[src_start,src_end,tgt_start,tgt_end].
.Sp
This is useful for converting a gapped alignment into a series of
nongapped alignments.
.Sp
In a list context this function will return a list of non-gapped
segments.
.SH "AUTHOR"
.IX Header "AUTHOR"
Lincoln Stein <lstein@cshl.org>.
.PP
Copyright (c) 2003 Cold Spring Harbor Laboratory
.PP
This package and its accompanying libraries is free software; you can
redistribute it and/or modify it under the terms of the \s-1GPL\s0 (either
version 1, or at your option, any later version) or the Artistic
License 2.0.  Refer to \s-1LICENSE\s0 for the full license text. In addition,
please see \s-1DISCLAIMER\s0.txt for disclaimers of warranty.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Bio::Graphics::Browser.
