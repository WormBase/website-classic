.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Bio::Graphics::Browser::Plugin 3"
.TH Bio::Graphics::Browser::Plugin 3 "2009-09-27" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "NAME"
Bio::Graphics::Browser::Plugin \-\- Base class for gbrowse plugins.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\& package Bio::Graphics::Browser::Plugin::MyPlugin;
\& use Bio::Graphics::Browser::Plugin;
\& use CGI ':standard';
\& @ISA = 'Bio::Graphics::Browser::Plugin';
.Ve
.PP
.Vb 2
\& # called by gbrowse to return name of plugin for popup menu
\& sub name        { 'Example Plugin' }
.Ve
.PP
.Vb 2
\& # called by gbrowse to return the descriptive verb for popup menu
\& sub verb        { 'Demonstrate' }
.Ve
.PP
.Vb 2
\& # called by gbrowse to return description of plugin
\& sub description { 'This is an example plugin' }
.Ve
.PP
.Vb 2
\& # called by gbrowse to return type of plugin
\& sub type        { 'annotator' }
.Ve
.PP
.Vb 6
\& # called by gbrowse to configure default settings for plugin
\& sub config_defaults {
\&     my $self = shift;
\&     return {foo => $value1,
\&             bar => $value2}
\& }
.Ve
.PP
.Vb 7
\& # called by gbrowse to reconfigure plugin settings based on CGI parameters
\& sub reconfigure {
\&   my $self = shift;
\&   my $current = $self->configuration;
\&   $current->{foo} = $self->config_param('foo');
\&   $current->{bar} = $self->config_param('bar');
\& }
.Ve
.PP
.Vb 11
\& # called by gbrowse to create a <form> fragment for changing settings
\& sub configure_form {
\&   my $self    = shift;
\&   my $current = $self->configuration;
\&   my $form = textfield(-name  => $self->config_name('foo'),
\&                        -value => $current->{foo})
\&              .
\&              textfield(-name  => $self->config_name('bar'),
\&                        -value => $current->{bar});
\&   return $form;
\& }
.Ve
.PP
.Vb 17
\& # called by gbrowse to annotate the DNA, returning features
\& sub annotate {
\&    my $self     = shift;
\&    my ($segment,$coordinate_mapper)  = @_;
\&    my $config   = $self->configuration;
\&    my $feature_list = $self->new_feature_list;
\&    $feature_list->add_type('my_type' => {glyph => 'generic',
\&                                          key   => 'my type',
\&                                          bgcolor => 'green',
\&                                          link    => 'http://www.google.com/search?q=$name'
\&                                         }
\&                           );
\&    # do something with the sequence segment
\&    my @features = do_something();
\&    $feature_list->add_feature($_ => 'my_type') foreach @features;
\&    return $feature_list;
\& }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is the base class for Generic Genome Browser plugins.  Plugins
are perl .pm files that are stored in the gbrowse.conf/plugins
directory.  Plugins are activated in the gbrowse.conf/ configuration
file by including them on the list indicated by the \*(L"plugins\*(R" setting:
.PP
.Vb 2
\& plugins = BatchDumper FastaDumper GFFDumper
\&           OligoFinder RestrictionAnnotator
.Ve
.PP
Site-specific plugins may be placed in one or more site-specific
directories and added to the plugin search path using the plugin_path
setting:
.PP
.Vb 1
\&  plugin_path = /usr/local/gbrowse_plugins
.Ve
.PP
GBrowse currently recognizes three distinct types of plugins:
.IP "1) dumpers" 4
.IX Item "1) dumpers"
These plugins receive the genomic segment object and generate a dump
\&\*(-- the output can be text, html or some other specialized
format. Example: \s-1GAME\s0 dumper.
.IP "2) finders" 4
.IX Item "2) finders"
These plugins accept input from the user and return a
list of genomic regions.  The main browser displays the found regions
and allows the user to select among them. Example: \s-1BLAST\s0 search.
.IP "3) annotators" 4
.IX Item "3) annotators"
These plugins receive the genomic segment object and either 1) return 
a list of features which are overlayed on top of the detailed view 
(Example: restriction site annotator) or 2) update the database with 
new or modified features and return nothing (Example: basic editor)
.PP
All plug-ins inherit from Bio::Graphics::Browser::Plugin, which
defines reasonable (but uninteresting) defaults for each of the
methods.  Specific behavior is then implemented by selectively
overriding certain methods.
.PP
The best way to understand how this works is to look at the source
code for some working plugins.  Examples provided with the gbrowse
distribution include:
.IP "GFFDumper.pm" 4
.IX Item "GFFDumper.pm"
A simple dumper which produces \s-1GFF\s0 format output representing the
features of the currently-selected segment.
.IP "FastaDumper.pm" 4
.IX Item "FastaDumper.pm"
A more complex dumper that illustrates how to create and manage
persistent user-modifiable settings.
.IP "SequenceDumper.pm" 4
.IX Item "SequenceDumper.pm"
Another dumper that shows how plugins interact with the Bio::SeqIO
system.
.IP "OligoFinder.pm" 4
.IX Item "OligoFinder.pm"
A finder that searches for short oligos in the entire database.  (Only
works with Bio::DB::GFF databases.)
.IP "RestrictionAnnotator.pm" 4
.IX Item "RestrictionAnnotator.pm"
An annotator that finds restriction sites in the currently selected
region of the genome.  It creates a new track for each type of
restriction site selected.
.IP "RandomGene.pm" 4
.IX Item "RandomGene.pm"
An example annotator that generates random gene-like structures in the
currently displayed region of the genome.  It's intended as a template
for front-ends to gene prediction programs.
.SH "METHODS"
.IX Header "METHODS"
The remainder of this document describes the methods available to the
programmer.
.Sh "\s-1INITIALIZATION\s0"
.IX Subsection "INITIALIZATION"
The initialization methods establish the human-readable name,
description, and basic operating parameters of the plugin.  They
should be overridden in each plugin you write.
.ie n .IP "$name = $self\fR\->\fIname()" 4
.el .IP "$name = \f(CW$self\fR\->\fIname()\fR" 4
.IX Item "$name = $self->name()"
Return a short human-readable name for the plugin.  This will be
displayed to the user in a menu using one of the following forms:
.Sp
.Vb 4
\&    Dump <name>
\&    Find <name>
\&    Annotate <name>
\&    plugin_defined_verb <name>
.Ve
.ie n .IP "$description = $self\fR\->\fIdescription()" 4
.el .IP "$description = \f(CW$self\fR\->\fIdescription()\fR" 4
.IX Item "$description = $self->description()"
This method returns a longer description for the plugin.  The text may
contain \s-1HTML\s0 tags, and should describe what the plugin does and who
wrote it.  This text is displayed when the user presses the \*(L"About...\*(R"
button.
.ie n .IP "$verb = $self\fR\->\fIverb()" 4
.el .IP "$verb = \f(CW$self\fR\->\fIverb()\fR" 4
.IX Item "$verb = $self->verb()"
This method returns a verb to be used in the plugin popup menu
in cases where the main three don't fit.  This method should
be set return whitespace or an empty string (not undefined) 
if you do not want a descriptive verb for the menu
.ie n .IP "$suppress_title = $self\fR\->\fIsuppress_title()" 4
.el .IP "$suppress_title = \f(CW$self\fR\->\fIsuppress_title()\fR" 4
.IX Item "$suppress_title = $self->suppress_title()"
The purpose of this methods is to suppress the 'Configure...'
or 'Find...' title that is printed at the top of the page when the 
plugin is loaded.  It will return false unless overriden by a plugin where
this behaviour is desired.
.ie n .IP "$type = $self\fR\->\fItype()" 4
.el .IP "$type = \f(CW$self\fR\->\fItype()\fR" 4
.IX Item "$type = $self->type()"
This tells gbrowse what the plugin's type is.  It must return one of
the scripts \*(L"dumper,\*(R" \*(L"finder,\*(R", \*(L"annotator\*(R" as described in the
introduction to this documentation.  If the method is not overridden,
\&\fItype()\fR will return \*(L"dumper.\*(R"
.IP "$self\->\fIinit()\fR" 4
.IX Item "$self->init()"
This method is called before any methods are invoked and allows the
plugin to do any run-time initialization it needs.  The default is to
do nothing.  Ordinarily this method does not need to be implemented.
.Sh "\s-1ACCESS\s0 \s-1TO\s0 \s-1THE\s0 \s-1ENVIRONMENT\s0"
.IX Subsection "ACCESS TO THE ENVIRONMENT"
The following methods give the plugin access to the environment,
including the gbrowse page settings, the sequence features database,
and the plugin's own configuration settings.
.PP
These methods do not generally need to be overridden.
.ie n .IP "$config = $self\fR\->\fIconfiguration()" 4
.el .IP "$config = \f(CW$self\fR\->\fIconfiguration()\fR" 4
.IX Item "$config = $self->configuration()"
Call this method to retrieve the persistent configuration for this
plugin.  The configuration is a hashref containing the default
configuration settings established by \fIconfig_defaults()\fR, possibly
modified by the user.  Due to cookie limitations, the values of the
hashref must be scalars or array references.
.Sp
See \s-1CONFIGURATION\s0 \s-1METHODS\s0 for instructions on how to create and
maintain the plugin's persistent configuration information.
.ie n .IP "$database = $self\->database" 4
.el .IP "$database = \f(CW$self\fR\->database" 4
.IX Item "$database = $self->database"
This method returns a copy of the sequence database.  Depending on the
data source chosen by the gbrowse administrator, this may be a
Bio::DB::GFF database, a Bio::DB::Das::Chado database, a Bio::Das
database, a Bio::DB::Das::BioSQL database, or any of the other
Das-like databases that gbrowse supports.
.ie n .IP "@track_names = $self\->selected_tracks" 4
.el .IP "@track_names = \f(CW$self\fR\->selected_tracks" 4
.IX Item "@track_names = $self->selected_tracks"
This method returns the list of track names that the user currently
has turned on.  Track names are the internal names identified in
gbrowse configuration file stanzas, for example \*(L"ORFs\*(R" in the
01.yeast.conf example file.
.ie n .IP "@feature_types = $self\->selected_features" 4
.el .IP "@feature_types = \f(CW$self\fR\->selected_features" 4
.IX Item "@feature_types = $self->selected_features"
This method returns the list of feature types that the user currently
has turned on.  Feature types are the feature identifiers indicated by
the \*(L"feature\*(R" setting in each track in the gbrowse configuration file,
for example \*(L"ORF:sgd\*(R" in the 01.yeast.conf [ORFs] track.
.ie n .IP "$gbrowse_settings = $self\->page_settings" 4
.el .IP "$gbrowse_settings = \f(CW$self\fR\->page_settings" 4
.IX Item "$gbrowse_settings = $self->page_settings"
This method returns a big hash containing the current gbrowse
persistent user settings.  These settings are documented in the
gbrowse executable source code.  You will not ordinarily need to
access the contents of this hash, and you should *not* change its
values.
.ie n .IP "$browser_config = $self\->browser_config" 4
.el .IP "$browser_config = \f(CW$self\fR\->browser_config" 4
.IX Item "$browser_config = $self->browser_config"
This method returns a copy of the Bio::Graphics::Browser object that
drives gbrowse.  This object allows you to interrogate (and change!)
the values set in the current gbrowse configuration file.
.Sp
The recommended use for this object is to recover plugin-specific
settings from the gbrowse configuration file.  These can be defined by
the gbrowse administrator by placing the following type of stanza into
the gbrowse config file:
.Sp
.Vb 3
\&  [GOSearch:plugin]
\&  traverse_isa = 1
\&  use_server   = http://amigo.geneontology.org
.Ve
.Sp
\&\*(L"GOSearch\*(R" is the package name of the plugin, and the \*(L":plugin\*(R" part
of the stanza name tells gbrowse that this is a plugin-private
configuration section.
.Sp
You can now access these settings from within the plugin by using the
following idiom:
.Sp
.Vb 3
\&   my $browser_config = $self->browser_config; 
\&   my $traverse_isa = $browser_config->plugin_setting('traverse_isa');
\&   my $server       = $browser_config->plugin_setting('use_server');
.Ve
.Sp
This facility is intended to be used for any settings that should not
be changed by the end user.  Persistent user preferences should be
stored in the hash returned by \fIconfiguration()\fR.
.ie n .IP "$language = $self\->language" 4
.el .IP "$language = \f(CW$self\fR\->language" 4
.IX Item "$language = $self->language"
This method returns the current I18n language file. You can use this
to make translations with the \fItr()\fR method:
.Sp
.Vb 1
\&  print $self->language->tr('WELCOME');
.Ve
.ie n .IP "$segments = $self\->segments" 4
.el .IP "$segments = \f(CW$self\fR\->segments" 4
.IX Item "$segments = $self->segments"
This method returns the current segments in use by gbrowse.  The active
segments are set from within gbrowse
.Sp
.Vb 1
\& $plugin->segments(\e@segments);
.Ve
.Sp
The active segments can then be retrieved from within the plugin.  This is 
useful in cases where segment-specific information is required by plugin methods
that are not passed a segment object.
.ie n .IP "$config_path   = $self\->config_path" 4
.el .IP "$config_path   = \f(CW$self\fR\->config_path" 4
.IX Item "$config_path   = $self->config_path"
This method returns the path to the directory in which gbrowse stores
its configuration files.  This is very useful for storing
plugin-specific configuration files.  See the sourcecode of
RestrictionAnnotator for an exmaple of this.
.ie n .IP "$feature_file  = $self\->new_feature_file" 4
.el .IP "$feature_file  = \f(CW$self\fR\->new_feature_file" 4
.IX Item "$feature_file  = $self->new_feature_file"
This method creates a new Bio::Graphics::FeatureFile for use by
annotators.  The \fIannotate()\fR method must invoke this method, configure
the resulting feature file, and then add one or more
Bio::Graphics::Feature objects to it.
.Sp
This method is equivalent to calling
Bio::Graphics::FeatureFile\->new(\-smart_features=>1), where the
\&\-smart_features argument allows features to be turned into imagemap
links.
.Sh "\s-1METHODS\s0 \s-1TO\s0 \s-1BE\s0 \s-1IMPLEMENTED\s0 \s-1IN\s0 \s-1DUMPERS\s0"
.IX Subsection "METHODS TO BE IMPLEMENTED IN DUMPERS"
All plugins that act as feature dumpers should override one or more of
the methods described in this section.
.IP "$self\->dump($segment)" 4
.IX Item "$self->dump($segment)"
Given a Bio::Das::SegmentI object, produce some output from its
sequence and/or features.  This can be used to dump something as
simple as a \s-1FASTA\s0 file, or as complex as a motif analysis performed on
the sequence.
.Sp
As described in Bio::Das::SegmentI, the segment object represents
the region of the genome currently on display in the gbrowse \*(L"detail\*(R"
panel.  You may call its \fIseq()\fR method to return the sequence as a
string, or its \fIfeatures()\fR method to return a list of all features that
have been annotated onto this segment of the genome.
.Sp
At the time that \fIdump()\fR is called, gbrowse will already have set up
the \s-1HTTP\s0 header and performed other initialization.  The \fIdump()\fR method
merely needs to begin printing output using the appropriate \s-1MIME\s0
type.  By default, the \s-1MIME\s0 type is text/plain, but this can be
changed with the \fImime_type()\fR method described next.  
.Sp
The following trivial example shows a \fIdump()\fR method that prints the
name and length of the segment:
.Sp
.Vb 6
\&  sub dump {
\&     my $self = shift;
\&     my $segment = shift;
\&     print "name   = ",$segment->seq_id,"\en";
\&     print "length = ",$segment->length,"\en";
\&  }
.Ve
.ie n .IP "$type = $self\->mime_type" 4
.el .IP "$type = \f(CW$self\fR\->mime_type" 4
.IX Item "$type = $self->mime_type"
Return the \s-1MIME\s0 type of the information produced by the plugin.  By
default, this method returns \*(L"text/plain\*(R".  Override it to return
another \s-1MIME\s0 type, such as \*(L"text/xml\*(R".
.Sh "\s-1METHODS\s0 \s-1TO\s0 \s-1BE\s0 \s-1IMPLEMENTED\s0 \s-1IN\s0 \s-1FINDERS\s0"
.IX Subsection "METHODS TO BE IMPLEMENTED IN FINDERS"
All finder plugins will need to override one or more of the methods
described in this section.
.ie n .IP "$features = $self\->find($segment);" 4
.el .IP "$features = \f(CW$self\fR\->find($segment);" 4
.IX Item "$features = $self->find($segment);"
The \fIfind()\fR method will be passed a Bio::Das::SegmentI segment object,
as described earlier for the \fIdump()\fR method.  Your code should search
the segment for features of interest, and return a two element
list. The first element should be an arrayref of Bio::SeqFeatureI
objects (see Bio::SeqFeatureI), or an empty list if nothing was
found. These synthetic feature objects should indicate the position,
name and type of the features found. The second element of the
returned list should be a (possibly shortened) version of the search
string for display in informational messages.
.Sp
Depending on the type of find you are performing, you might search the
preexisting features on the segment for matches, or create your own
features from scratch in the way that the annotator plugins do.  You
may choose to ignore the passed segment and perform the search on the
entire database, which you can obtain using the \fIdatabase()\fR method
call.
.Sp
To create features from scratch I suggest you use either
Bio::Graphics::Feature, or Bio::SeqFeature::Generic to generate the
features.  See their respective manual pages for details, and the
OligoFinder.pm plugin for an example of how to do this.
.Sp
If the plugin requires user input before it can perform its task,
\&\fIfind()\fR should return undef.  Gbrowse will invoke \fIconfigure_form()\fR
followed by \fIreconfigure()\fR in order to prompt the user for input.  If
nothing is found, the plugin should return an empty list.  The
following is an example of how to prompt the user for input \*(-- in this
case, a gene ontology term:
.Sp
.Vb 9
\&  sub find {
\&     my $self = shift;
\&     my $segment  = shift;  # we ignore this!
\&     my $config   = $self->configuration;
\&     my $query    = $config->{query} or return undef;  # PROMPT FOR INPUT
\&     my $database = $self->database;
\&     my @features = $database->features(-attributes=>{GO_Term => $query});
\&     return (\e@features,$query); 
\&  }
.Ve
.Sp
.Vb 5
\&  sub configure_form {
\&     my $self = shift;
\&     return "Enter a GO Term: "
\&            . textfield(-name=>$self->config_name('query'));
\&  }
.Ve
.Sp
.Vb 5
\&  sub reconfigure {
\&     my $self = shift;
\&     my $config = $self->configuration;
\&     $config->{query} = $self->config_param('query');
\&  }
.Ve
.Sp
See the sections below for more description of the \fIconfigure_form()\fR
and \fIreconfigure()\fR methods.  
.Sp
\&\s-1NOTE:\s0 If you need to use auxiliary files like \s-1BLAST\s0 files, you can
store the location of those files in the gbrowse .conf file under the
stanza [YourPlugin:plugin]:
.Sp
.Vb 2
\&   [YourPlugin:plugin]
\&   blast_path = /usr/local/blast/databases
.Ve
.Sp
.Vb 6
\&   sub find {
\&      my $self = shift;
\&      my $segment = shift;  # ignored
\&      my $blast_path = $self->browser_config->plugin_setting('blast_path');
\&      # etc etc etc  
\&   }
.Ve
.Sh "\s-1METHODS\s0 \s-1TO\s0 \s-1BE\s0 \s-1IMPLEMENTED\s0 \s-1IN\s0 \s-1ANNOTATORS\s0"
.IX Subsection "METHODS TO BE IMPLEMENTED IN ANNOTATORS"
All annotator plugins will need to override the method described in
this section.
.ie n .IP "$feature_file = $plugin\->annotate($segment[,$coordinate_mapper])" 4
.el .IP "$feature_file = \f(CW$plugin\fR\->annotate($segment[,$coordinate_mapper])" 4
.IX Item "$feature_file = $plugin->annotate($segment[,$coordinate_mapper])"
The \fIannotate()\fR method will be invoked with a Bio::Das::SegmentI
segment representing the region of the genome currently on view in the
gbrowse detail panel.  The method should first call its own
\&\fInew_feature_list()\fR to create a Bio::Graphics::FeatureFile feature set
object, and define one or more feature types to added to the feature
set.  The method should then create one or more Bio::Graphics::Feature
objects and add them to the feature set using add_feature.
.Sp
The reason that \fIannotate()\fR returns a Bio::Graphics::FeatureFile rather
than an array of features the way that \fIfind()\fR does is because
Bio::Graphics::FeatureFile also allows you to set up how the features
will be rendered; you can define tracks, assign different feature
types to different tracks, and assign each feature type a glyph,
color, and other options.
.Sp
The \fIannotate()\fR function will also be passed a coordinate_mapper
variable.  This is a code ref to a function that will transform
coordinates from relative to absolute coordinates.  The function takes
a reference sequence name and a list of [$start,$end] coordinate
pairs, and returns a similar function result, except that the sequence
name and coordinates are all in absolute coordinate space.  Currently
there are no plugins that make use of this facility.
.Sp
See Bio::Graphics::FeatureFile for details, and the
RestrictionAnnotator.pm plugin for an example.
.Sh "\s-1PERSISTENT\s0 \s-1CONFIGURATION\s0 \s-1METHODS\s0"
.IX Subsection "PERSISTENT CONFIGURATION METHODS"
The following methods can be called to retrieve data about the
environment in which the plugin is running.  These methods are also
used by gbrowse to change the plugin state.
.ie n .IP "$config = $self\fR\->\fIconfig_defaults()" 4
.el .IP "$config = \f(CW$self\fR\->\fIconfig_defaults()\fR" 4
.IX Item "$config = $self->config_defaults()"
This method will be called once at plugin startup time to give the
plugin a chance to set up its default configuration state.  If you
implement this method you should return the configuration as a hash
reference in which the values of the hash are either scalar values or
array references.  The contents of this hash will be placed in a
CGI::Session.
.Sp
You will wish to implement this method if the plugin has
user-modifiable settings.
.Sp
\&\s-1NOTE\s0 \s-1ON\s0 \s-1FILEHANDLES:\s0 You are not allowed to permanently store a
filehandle in the persistent configuration data structure because the
session-handling code will try to serialize and store the filehandle,
which is not allowed by the default serializer. If you must store a
filehandle in the configuration data structure, be sure to delete it
within the \fIannotate()\fR, \fIfind()\fR or \fIdump()\fR methods once you are finished
using it.
.IP "$self\->\fIconfigure_form()\fR" 4
.IX Item "$self->configure_form()"
This method will be called when the user presses the \*(L"Configure
plugin\*(R" button.  You should return the \s-1HTML\s0 for a fill-out form that
allows the user to change the current settings.  The \s-1HTML\s0 should
contain the contents of an \s-1HTML\s0 <form> section, but \fBnot\fR the actual
<form> and </form> tags.  These tags, along with the Submit and Cancel
buttons, will be added automatically.  Typically you will build up the
\&\s-1HTML\s0 to return using a series of .= append operations.
.Sp
It is highly recommended that you use the \s-1CGI\s0 module to generate the
fill-out form.  In order to avoid clashing with other parts of
gbrowse, plugin fill-out forms must respect a namespacing convention
in which the name of each form field is preceded by the plugin package
name and a dot.  The package name is the last component of the
plugin's package; for example \*(L"GoSearch\*(R" is the package name for
Bio::Graphics::Browser::Plugin::GoSearch. To represent the \*(L"query\*(R"
field of the plugin named \*(L"GOSearch\*(R", the text field must be named
\&\*(L"GOSearch.query\*(R".
.Sp
To make this easier to do right, the Plugin module provides a method
named \fIconfig_name()\fR which will add the prefix for you.  Here is how
to use it with the \*(L"query\*(R" example:
.Sp
.Vb 1
\&   $html .= textfield(-name  => $self->config_name('query'));
.Ve
.IP "$self\->\fIreconfigure()\fR" 4
.IX Item "$self->reconfigure()"
If you implement a \fIconfigure_form()\fR method, you must also implement a
\&\fIreconfigure()\fR method.  This method is called after the user submits
the form and should be used to integrate the form values with the
current configuration.
.Sp
Remember that the form fields are namespaced.  You may recover them
using the \s-1CGI\s0 \fIparam()\fR method by preceding them with the proper prefix.
To make this easier to manage, this module provides a \fIconfig_param()\fR
method that manages the namespaces transparently.
.Sp
Here is a working example:
.Sp
.Vb 5
\&  sub reconfigure {
\&      my $self = shift;
\&      my $current_configuration = $self->configuration;
\&      $current_configuration->{query} = $self->config_param('query');
\&  }
.Ve
.Sp
All this does is to retrieve the current configuration by calling the
\&\fIconfiguration()\fR method.  The value of the \*(L"query\*(R" key is then replaced
by a fill-out form parameter named \*(L"query\*(R", using \fIconfig_param()\fR
instead of the more familiar \s-1CGI\s0 module's \fIparam()\fR function.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Bio::Graphics::Browser
.SH "AUTHOR"
.IX Header "AUTHOR"
Lincoln Stein <lstein@cshl.org>.
.PP
Copyright (c) 2003 Cold Spring Harbor Laboratory
.PP
This package and its accompanying libraries is free software; you can
redistribute it and/or modify it under the terms of the \s-1GPL\s0 (either
version 1, or at your option, any later version) or the Artistic
License 2.0.  Refer to \s-1LICENSE\s0 for the full license text. In addition,
please see \s-1DISCLAIMER\s0.txt for disclaimers of warranty.
