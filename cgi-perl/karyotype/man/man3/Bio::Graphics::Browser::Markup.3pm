.\" Automatically generated by Pod::Man 2.1801 (Pod::Simple 3.08)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Bio::Graphics::Browser::Markup 3"
.TH Bio::Graphics::Browser::Markup 3 "2009-09-27" "perl v5.10.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Bio::Graphics::Browser::Markup \- Markup routines for sequences in text form
.SH "VERSION (CVS-info)"
.IX Header "VERSION (CVS-info)"
.Vb 4
\& $RCSfile: Markup.pm,v $
\& $Revision: 1.3.14.1 $
\& $Author: lstein $
\& $Date: 2007\-10\-17 01:48:21 $
.Ve
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& use Bio::Graphics::Browser::Markup;
\&
\& my $string = join \*(Aq\*(Aq,\*(Aqa\*(Aq..\*(Aqz\*(Aq,\*(Aqa\*(Aq..\*(Aqz\*(Aq,\*(Aqa\*(Aq..\*(Aqz\*(Aq;
\& my $markup = Bio::Graphics::Browser::Markup\->new;
\&
\& $markup\->add_style(cds=>\*(AqUPPERCASE\*(Aq);
\& $markup\->add_style(exon     =>\*(AqText\-decoration: underline\*(Aq);
\& $markup\->add_style(variation=>\*(AqFont\-weight: bold\*(Aq);
\& $markup\->add_style(italic=>\*(AqFont\-style: oblique\*(Aq);
\& $markup\->add_style(yellow=>\*(AqBGCOLOR blue\*(Aq);
\& $markup\->add_style(green=>\*(AqBGCOLOR red\*(Aq);
\& $markup\->add_style(orange=>\*(AqBGCOLOR orange\*(Aq);
\& $markup\->add_style(mango=>\*(AqFGCOLOR red\*(Aq);
\& $markup\->add_style(br=>\*(Aq<br>\*(Aq);
\& $markup\->markup(\e$string,[
\&                          [\*(Aqcds\*(Aq,1=>10],
\&                          [\*(Aqcds\*(Aq,12=>15],
\&                          [\*(Aqvariation\*(Aq,20=>41],
\&                          [\*(Aqexon\*(Aq,0=>29],
\&                          [\*(Aqexon\*(Aq,32=>40], 
\&                          [\*(Aqitalic\*(Aq,18=>29],
\&                          [\*(Aqyellow\*(Aq,5=>40],
\&                          [\*(Aqgreen\*(Aq,20=>50],
\&                          [\*(Aqorange\*(Aq,30=>60],
\&                          [\*(Aqmango\*(Aq,0=>36],
\&                          [\*(Aqbr\*(Aq,10=>10],
\&                          [\*(Aqbr\*(Aq,20=>20],
\&                          [\*(Aqbr\*(Aq,30=>30],
\&                          [\*(Aqbr\*(Aq,40=>40],
\&                          [\*(Aqbr\*(Aq,50=>50],
\&                          [\*(Aqbr\*(Aq,60=>60],
\&                          ]);
\& print $string,"\en";
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module marks up a string with \s-1HTML\s0 cascading stylesheet styles in
such a way that intersecting regions contain the union of the two
intersecting styles.  It also handles colors in such a way that
intersecting colors are added up.
.SH "METHODS"
.IX Header "METHODS"
.ie n .SS "$annotator = Bio::Graphics::Browser::Markup\->new"
.el .SS "\f(CW$annotator\fP = Bio::Graphics::Browser::Markup\->new"
.IX Subsection "$annotator = Bio::Graphics::Browser::Markup->new"
Create a new Markup object.
.ie n .SS "$old_style = $annotator\->add_style($symbolic_name=>$style)"
.el .SS "\f(CW$old_style\fP = \f(CW$annotator\fP\->add_style($symbolic_name=>$style)"
.IX Subsection "$old_style = $annotator->add_style($symbolic_name=>$style)"
Add an annotation style.
.PP
\&\f(CW$symbolic\fR name is a unique identifier to be used for ornamenting the
string.
.PP
\&\f(CW$style\fR is one of:
.PP
.Vb 9
\&   \- a CSS/2 stylesheet entry of form "style: value"
\&   \- the word   "UPPERCASE"         (make uppercase)
\&   \- the word   "LOWERCASE"         (make lowercase)
\&   \- the phrase "FGCOLOR #RRGGBB"   (foreground color)
\&   \- the phrase "FGCOLOR color\-name"
\&   \- the phrase "BGCOLOR #RRGGBB"   (background color)
\&   \- the phrase "BGCOLOR color\-name"
\&   \- an HTML tag, indicated by a leading "E<lt>" character
\&   \- anything else, will be inserted blindly
.Ve
.PP
When calculating intersected regions, styles will be aggregated, upper
and lowercasing will be performed directly on the data, colors will be
additive, and \s-1HTML\s0 will be inserted blindly.
.PP
An invalid color name will cause this module to die.  Valid color
names can be obtained this way:
.PP
.Vb 2
\& perl \-MBio::Graphics::Panel \e
\&      \-e \*(Aqprint join "\en",sort Bio::Graphics::Panel\->color_names\*(Aq
.Ve
.ie n .SS "$style = $annotator\->style($symbolic_name)"
.el .SS "\f(CW$style\fP = \f(CW$annotator\fP\->style($symbolic_name)"
.IX Subsection "$style = $annotator->style($symbolic_name)"
Get the style corresponding to symbolic name, or undef if the name is
unrecognized.
.ie n .SS "$style = $annotator\->get_style($symbolic_name)"
.el .SS "\f(CW$style\fP = \f(CW$annotator\fP\->get_style($symbolic_name)"
.IX Subsection "$style = $annotator->get_style($symbolic_name)"
Get a list of \s-1CSS/2\s0 styles corresponding to symbolic name.  Will die
if the name is not recognized or does not correspond to an entry of
type \*(L"style\*(R".
.ie n .SS "$flag = $annotator\->valid_symbol($symbolic_name)"
.el .SS "\f(CW$flag\fP = \f(CW$annotator\fP\->valid_symbol($symbolic_name)"
.IX Subsection "$flag = $annotator->valid_symbol($symbolic_name)"
Return true if the symbolic name is valid.
.ie n .SS "$result = $annotator\->markup(\e$sequence,\e@annotated_regions)"
.el .SS "\f(CW$result\fP = \f(CW$annotator\fP\->markup(\e$sequence,\e@annotated_regions)"
.IX Subsection "$result = $annotator->markup($sequence,@annotated_regions)"
Mark up the string referenced by \f(CW$sequence\fR, according to the regions
contained in \f(CW$annotated_regions\fR.
.PP
\&\f(CW$sequence\fR is a scalar ref, which will be modified in place (make a
copy of it if you need to).  \f(CW$annotated_regions\fR is a arrayref to the
following list:
.PP
.Vb 1
\&  ([symbolic_name,start,end], [symbolic_name,start,end], ....)
.Ve
.PP
The result indicates whether the markup was successful.
.PP
\&\s-1IMPORTANT:\s0 Regions are numbered using space-oriented coordinates,
which means that start=0 means to insert in front of the first base
pair, and an end equal to the sequence length will insert after the
last base pair:
.PP
.Vb 4
\&  0 1 2 3 4 5 6 7     perl string coordinates
\&  1 2 3 4 5 6 7 8     sequence coordinates
\&  g a t c g a t c     sequence
\& 0 1 2 3 4 5 6 7 8    space coordinates
\&
\& To select first base:                    start=0, end=1
\& To insert markup between bases 1 and 2:  start=1, end=1
\& To select last base:                     start=7, end=8
\& To select entire sequence:               start=0, end=8
.Ve
.PP
This means that some munging of the sequence annotation must be
performed, but it keeps the notation unambiguous.
.SS "Internal Methods (not for external use; documentation incomplete)"
.IX Subsection "Internal Methods (not for external use; documentation incomplete)"
.ie n .IP "@events = $annotator\->_add_colors($style_tag,$regions)" 4
.el .IP "\f(CW@events\fR = \f(CW$annotator\fR\->_add_colors($style_tag,$regions)" 4
.IX Item "@events = $annotator->_add_colors($style_tag,$regions)"
.PD 0
.ie n .IP "$style_symbol = $annotator\->_add_colors($style_tag,$regions)" 4
.el .IP "\f(CW$style_symbol\fR = \f(CW$annotator\fR\->_add_colors($style_tag,$regions)" 4
.IX Item "$style_symbol = $annotator->_add_colors($style_tag,$regions)"
.ie n .IP "$color = $annotator\->_add_color($color1,$color2)" 4
.el .IP "\f(CW$color\fR = \f(CW$annotator\fR\->_add_color($color1,$color2)" 4
.IX Item "$color = $annotator->_add_color($color1,$color2)"
.ie n .IP "$color = $annotator\->_subtract_color($color1,$color2)" 4
.el .IP "\f(CW$color\fR = \f(CW$annotator\fR\->_subtract_color($color1,$color2)" 4
.IX Item "$color = $annotator->_subtract_color($color1,$color2)"
.ie n .IP "$html_color = $annotator\->_to_html_color($color)" 4
.el .IP "\f(CW$html_color\fR = \f(CW$annotator\fR\->_to_html_color($color)" 4
.IX Item "$html_color = $annotator->_to_html_color($color)"
.ie n .IP "@tag_positions = $annotator\->_unify($region_definitions)" 4
.el .IP "\f(CW@tag_positions\fR = \f(CW$annotator\fR\->_unify($region_definitions)" 4
.IX Item "@tag_positions = $annotator->_unify($region_definitions)"
.ie n .IP "$style_fragment = $annotator\->_to_style($symbols)" 4
.el .IP "\f(CW$style_fragment\fR = \f(CW$annotator\fR\->_to_style($symbols)" 4
.IX Item "$style_fragment = $annotator->_to_style($symbols)"
.ie n .IP "@tag_positions = $annotator\->_linearize_html($region_definitions)" 4
.el .IP "\f(CW@tag_positions\fR = \f(CW$annotator\fR\->_linearize_html($region_definitions)" 4
.IX Item "@tag_positions = $annotator->_linearize_html($region_definitions)"
.ie n .IP "\e@events = $annotator\->_regions_to_events($regions)" 4
.el .IP "\e@events = \f(CW$annotator\fR\->_regions_to_events($regions)" 4
.IX Item "@events = $annotator->_regions_to_events($regions)"
.PD
turn a series of regions into a series of start and end events
because of the problem of events that start/stop in the same place
each event also gets a sequence that can be used to keep events
matched in a nested way
.ie n .IP "$annotator\->_add_markup($string_to_modify,$tag_positions)" 4
.el .IP "\f(CW$annotator\fR\->_add_markup($string_to_modify,$tag_positions)" 4
.IX Item "$annotator->_add_markup($string_to_modify,$tag_positions)"
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Bio::Graphics::Panel,
Bio::Graphics::Glyph,
Bio::Graphics::Feature,
Bio::Graphics::FeatureFile,
Bio::Graphics::Browser,
Bio::Graphics::Browser::Plugin
.SH "AUTHOR"
.IX Header "AUTHOR"
Lincoln Stein <lstein@cshl.org>.
.PP
Copyright (c) 2002 Cold Spring Harbor Laboratory
.PP
This package and its accompanying libraries is free software; you can
redistribute it and/or modify it under the terms of the \s-1GPL\s0 (either
version 1, or at your option, any later version) or the Artistic
License 2.0.  Refer to \s-1LICENSE\s0 for the full license text. In addition,
please see \s-1DISCLAIMER\s0.txt for disclaimers of warranty.
